/* This file contains all recepies regarding unordered maps */

#include <iostream>
#include <unordered_map>
#include <utility>
#include <algorithm>
#include <cassert>
#include "unordered_map.h"

using namespace std;

static void print_map(const unordered_map<int, int>& m)
{
    cout << "Map elements: { ";
    for_each(m.begin(), m.end(), [](auto it){cout << it.first << " : " << it.second << ", ";});
    cout << " }\n";
}

/////////////////////////////////////////////////////////////////////////////////////////////
// RECEPIE 1: Using unordered_map with non comparable types as a key

/* Sometimes we may need to use map with non comparable type as a key.

It cannot be done with standard map, beacouse in standard map the node localisation
depends on its position in a tree. That means, that the elements has to be placed in a tree
according to specified schema.

With unordered map we use hash table to locate the element. Each key has assigned hash value
generated by hash function.

The hash function in STL is counted by operator() of hash structure, specialized with type given as
a template. The STL provides hash structures for basic types, like int, but we can also extend
it by writing own specialisation of the hash structure with our type.

We may also define any other structure with operator() that will count hash value for the type, and
pass it as 3rd argument of a template when defining unordered map.

Other think we need is to define == operator of a key type.

Example
*/

// Own type definition
struct own_type{
    int x;
    int y;
};


// Operator == implementation
bool operator==(const own_type l, const own_type r)
{
    return ((l.x == r.x) && (l.y == r.y));
}

// Specialization of hash struct for own type
namespace std{
    template<>
    struct hash<own_type>
    {
        using argument_type = own_type;
        using result_type = size_t;

        result_type operator()(const argument_type& arg) const
        {
            return arg.x + arg.y;
        }
    };
}

// nd now we can use map with our type as a key
void own_type_key_example()
{
    cout << "Unordered map - own type key example! \n\n";
    cout << "We wil create a map with own_type as key type, created map: { ";

    unordered_map<own_type, int> mapa{{{0,0},1}, {{1,1},2}, {{2,2},3}};

    for (const auto & [key, value] : mapa)
    {
        cout << "{( " << key.x << " , " << key.y << " ) : " << value << " }, ";
    }
    cout << "}\n\n";
}

void unordered_map_example()
{
    cout << "Unordered map recepies examples!  \n\n";
    own_type_key_example();
}